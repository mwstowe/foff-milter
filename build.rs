use std::env;
use std::fs;
use std::path::Path;
use std::process::Command;

fn main() {
    eprintln!("=== Running build.rs ===");

    // Get git commit hash
    let output = Command::new("git")
        .args(["rev-parse", "--short=8", "HEAD"])
        .output();

    let git_hash = match output {
        Ok(output) if output.status.success() => String::from_utf8(output.stdout)
            .unwrap_or_else(|_| "unknown".to_string())
            .trim()
            .to_string(),
        _ => "unknown".to_string(),
    };

    eprintln!("=== Git hash: {} ===", git_hash);

    // Get git commit date
    let output = Command::new("git")
        .args(["log", "-1", "--format=%ci"])
        .output();

    let git_date = match output {
        Ok(output) if output.status.success() => String::from_utf8(output.stdout)
            .unwrap_or_else(|_| "unknown".to_string())
            .split_whitespace()
            .next()
            .unwrap_or("unknown")
            .to_string(),
        _ => "unknown".to_string(),
    };

    // Check if working directory is clean
    let output = Command::new("git").args(["status", "--porcelain"]).output();

    let is_dirty = match output {
        Ok(output) if output.status.success() => !output.stdout.is_empty(),
        _ => false,
    };

    let dirty_suffix = if is_dirty { "-dirty" } else { "" };

    // Generate version.rs file
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("version_gen.rs");

    let version_code = format!(
        r#"// Auto-generated by build.rs

pub const VERSION: &str = concat!(env!("CARGO_PKG_VERSION"), "+{}", "{}");
pub const GIT_HASH: &str = "{}";
pub const GIT_DATE: &str = "{}";
pub const CARGO_VERSION: &str = env!("CARGO_PKG_VERSION");
"#,
        git_hash, dirty_suffix, git_hash, git_date
    );

    fs::write(&dest_path, version_code).unwrap();
    eprintln!("=== Wrote version file to {:?} ===", dest_path);

    // Rebuild if git HEAD changes
    println!("cargo:rerun-if-changed=.git/HEAD");
}
